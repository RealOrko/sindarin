// Test: UDP lastSender property
// Tests that sender address is correctly captured and accessible

fn main(): void =>
    // Create two local UDP sockets
    var receiver: UdpSocket = UdpSocket.bind("127.0.0.1:0")
    var sender: UdpSocket = UdpSocket.bind("127.0.0.1:0")

    var recvPort: int = receiver.port
    var sendPort: int = sender.port

    print("Receiver bound\n")
    print("Sender bound\n")

    // Test 1: lastSender is empty before receiving
    var initialSender: str = receiver.lastSender
    if initialSender == "" =>
        print("Test 1 PASS: lastSender empty initially\n")
    else =>
        print("Test 1 FAIL: lastSender not empty\n")

    // Send a datagram
    var message: byte[] = "Test message".toBytes()
    sender.sendTo(message, $"127.0.0.1:{recvPort}")
    print("Datagram sent\n")

    // Receive it
    var data: byte[] = receiver.receiveFrom(1024)
    if data.toString() == "Test message" =>
        print("Received correctly\n")
    else =>
        print("Received incorrectly\n")

    // Test 2: lastSender contains correct IP
    var lastSender: str = receiver.lastSender
    if lastSender.contains("127.0.0.1") =>
        print("Test 2 PASS: lastSender contains IP\n")
    else =>
        print("Test 2 FAIL: lastSender missing IP\n")

    // Test 3: lastSender contains sender's port
    if lastSender.contains($"{sendPort}") =>
        print("Test 3 PASS: lastSender contains port\n")
    else =>
        print("Test 3 FAIL: lastSender missing port\n")

    // Test 4: Can reply using lastSender
    var reply: byte[] = "Reply".toBytes()
    receiver.sendTo(reply, lastSender)

    var replyData: byte[] = sender.receiveFrom(1024)
    if replyData.toString() == "Reply" =>
        print("Test 4 PASS: Reply received via lastSender\n")
    else =>
        print("Test 4 FAIL: Reply not received\n")

    receiver.close()
    sender.close()
    print("All sender tests complete\n")
