// Test: Parallel TCP connections using & operator
// Demonstrates making concurrent requests and getting string results

import "../../sdk/time"

fn handleClient(client: TcpStream, message: str): void =>
    client.write(message.toBytes())
    client.close()

fn runServer(listener: TcpListener): int =>
    // Accept and handle 3 connections
    var c1: TcpStream = listener.accept()
    handleClient(c1, "DATA1")

    var c2: TcpStream = listener.accept()
    handleClient(c2, "DATA2")

    var c3: TcpStream = listener.accept()
    handleClient(c3, "DATA3")

    return 0

fn fetchData(addr: str): str =>
    var conn: TcpStream = TcpStream.connect(addr)
    var data: byte[] = conn.read(1024)
    conn.close()
    return data.toString()

fn main(): void =>
    print("Testing parallel TCP connections\n")

    // Create server on OS-assigned port
    var listener: TcpListener = TcpListener.bind("127.0.0.1:0")
    var port: int = listener.port
    var addr: str = $"127.0.0.1:{port}"

    // Start server in background thread
    var serverThread: int = &runServer(listener)

    // Delay to ensure server is accepting
    SnTime.sleep(100)

    print("Server ready\n")

    // Fetch data from server 3 times in parallel
    var result1: str = &fetchData(addr)
    var result2: str = &fetchData(addr)
    var result3: str = &fetchData(addr)

    // Sync all requests
    result1!
    result2!
    result3!
    print("All requests completed in parallel\n")

    // Verify we got data from each (order may vary due to parallel execution)
    var count: int = 0
    if result1.length > 0 =>
        count = count + 1
    if result2.length > 0 =>
        count = count + 1
    if result3.length > 0 =>
        count = count + 1

    if count == 3 =>
        print("SUCCESS: All parallel requests returned data\n")
    else =>
        print("FAILURE: Some requests returned no data\n")

    // Wait for server to finish
    serverThread!

    listener.close()
    print("Test complete\n")
