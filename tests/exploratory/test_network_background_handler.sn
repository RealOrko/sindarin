// Test: Background client handlers using &handleClient pattern
// Demonstrates the fire-and-forget pattern for handling connections
// Note: Server uses Python due to threading limitations with TcpListener.accept()

fn handleConnection(addr: str): void =>
    // Connect to server and handle the interaction
    var conn: TcpStream = TcpStream.connect(addr)
    var data: byte[] = conn.read(1024)
    // Handler processes data in background (fire and forget)
    conn.close()

fn main(): void =>
    print("Testing background client handlers\n")

    // Clean up any leftover port file from previous runs
    var preclean: Process = Process.run("rm", {"-f", "/tmp/tcp_bg_port"})

    // Start a Python server that binds to port 0 (OS assigns free port),
    // calls listen(), THEN writes the port to a file (to avoid race condition)
    var server: Process = &Process.run("python3", {"-c", "import socket;s=socket.socket();s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1);s.bind(('127.0.0.1',0));port=s.getsockname()[1];s.listen(5);f=open('/tmp/tcp_bg_port','w');f.write(str(port));f.flush();f.close();c1,a1=s.accept();c1.send(b'HELLO1');c1.close();c2,a2=s.accept();c2.send(b'HELLO2');c2.close();c3,a3=s.accept();c3.send(b'HELLO3');c3.close();s.close()"})

    // Wait for server to be ready and get the port
    var attempts: int = 0
    while attempts < 50 =>
        var check: Process = Process.run("test", {"-f", "/tmp/tcp_bg_port"})
        if check.exitCode == 0 =>
            attempts = 100
        else =>
            var wait: Process = Process.run("sleep", {"0.05"})
            attempts = attempts + 1

    if attempts < 100 =>
        print("Server not ready\n")
        return

    // Read the port from the file
    var portFile: TextFile = TextFile.open("/tmp/tcp_bg_port")
    var portStr: str = portFile.readLine()
    portFile.close()
    var addr: str = $"127.0.0.1:{portStr}"

    print("Server ready\n")

    // Fire off 3 handlers in background using & operator (fire and forget pattern)
    // This demonstrates the &handleClient(client) pattern from the spec
    &handleConnection(addr)
    &handleConnection(addr)
    &handleConnection(addr)

    print("All handlers spawned (fire and forget)\n")

    // Wait for Python server to finish - this ensures all connections were accepted
    server!
    print("Server finished - all handlers processed\n")

    print("SUCCESS: Background handler pattern works\n")

    var cleanup: Process = Process.run("rm", {"-f", "/tmp/tcp_bg_port"})
    print("Test complete\n")
