// Test: Background client handlers using &handleClient pattern
// Demonstrates the fire-and-forget pattern for handling connections
// Uses native Sindarin TcpListener instead of Python
// Cross-platform: works on Windows, Linux, and macOS

import "../../sdk/time"

fn handleConnection(addr: str): void =>
    // Connect to server and handle the interaction
    var conn: TcpStream = TcpStream.connect(addr)
    var data: byte[] = conn.read(1024)
    // Handler processes data in background (fire and forget)
    conn.close()

fn runServer(listener: TcpListener): int =>
    // Accept and handle 3 connections
    var c1: TcpStream = listener.accept()
    c1.write("HELLO1".toBytes())
    c1.close()

    var c2: TcpStream = listener.accept()
    c2.write("HELLO2".toBytes())
    c2.close()

    var c3: TcpStream = listener.accept()
    c3.write("HELLO3".toBytes())
    c3.close()

    return 0

fn main(): void =>
    print("Testing background client handlers\n")

    // Create server on OS-assigned port
    var listener: TcpListener = TcpListener.bind("127.0.0.1:0")
    var port: int = listener.port
    var addr: str = $"127.0.0.1:{port}"

    // Start server in background thread
    var serverThread: int = &runServer(listener)

    // Delay to ensure server is accepting (Windows needs more time)
    SnTime.sleep(100)

    print("Server ready\n")

    // Fire off 3 handlers in background using & operator (fire and forget pattern)
    // This demonstrates the &handleClient(client) pattern from the spec
    &handleConnection(addr)
    &handleConnection(addr)
    &handleConnection(addr)

    print("All handlers spawned (fire and forget)\n")

    // Wait for server to finish - this ensures all connections were accepted
    serverThread!
    print("Server finished - all handlers processed\n")

    print("SUCCESS: Background handler pattern works\n")

    listener.close()
    print("Test complete\n")
