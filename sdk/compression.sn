# ==============================================================================
# sdk/compression.sn - Compression Library for Sindarin
# ==============================================================================
# Provides zlib compression/decompression bindings and high-level wrappers.
#
# Usage:
#   import "sdk/compression" as zlib
#
#   // High-level API (recommended)
#   var compressed: byte[] = zlib.compress_data(data)
#   var original: byte[] = zlib.decompress_data(compressed, original_size)
#
#   // With compression level (0-9, default 6)
#   var fast: byte[] = zlib.compress_data_level(data, 1)      // Fastest
#   var best: byte[] = zlib.compress_data_level(data, 9)      // Best compression
#
# Requirements:
#   - zlib library must be installed (libz)
#   - Linux: sudo apt install zlib1g-dev
#   - macOS: brew install zlib (usually pre-installed)
#   - Windows: Install zlib via vcpkg or download from zlib.net
# ==============================================================================

#pragma link "z"

# ==============================================================================
# Error Codes
# ==============================================================================
# zlib returns these error codes from compression/decompression functions.

fn Z_OK(): int =>
    return 0

fn Z_STREAM_END(): int =>
    return 1

fn Z_NEED_DICT(): int =>
    return 2

fn Z_ERRNO(): int =>
    return -1

fn Z_STREAM_ERROR(): int =>
    return -2

fn Z_DATA_ERROR(): int =>
    return -3

fn Z_MEM_ERROR(): int =>
    return -4

fn Z_BUF_ERROR(): int =>
    return -5

fn Z_VERSION_ERROR(): int =>
    return -6

# ==============================================================================
# Compression Levels
# ==============================================================================

fn Z_NO_COMPRESSION(): int =>
    return 0

fn Z_BEST_SPEED(): int =>
    return 1

fn Z_BEST_COMPRESSION(): int =>
    return 9

fn Z_DEFAULT_COMPRESSION(): int =>
    return -1

# ==============================================================================
# Low-Level zlib Bindings
# ==============================================================================
# These are direct bindings to the zlib C library.
# For most use cases, prefer the high-level wrappers below.

# compress2 - Compress with specified level
native fn compress2(dest: *byte, destLen: uint as ref, source: *byte, sourceLen: uint, level: int): int

# compress - Compress with default level
native fn compress(dest: *byte, destLen: uint as ref, source: *byte, sourceLen: uint): int

# uncompress - Decompress data
native fn uncompress(dest: *byte, destLen: uint as ref, source: *byte, sourceLen: uint): int

# compressBound - Calculate upper bound for compressed size
native fn compressBound(sourceLen: uint): uint

# ==============================================================================
# Error Message Helper
# ==============================================================================

fn error_message(code: int): str =>
    if code == Z_OK() =>
        return "OK"
    if code == Z_STREAM_END() =>
        return "Stream end"
    if code == Z_NEED_DICT() =>
        return "Need dictionary"
    if code == Z_ERRNO() =>
        return "File error"
    if code == Z_STREAM_ERROR() =>
        return "Stream error"
    if code == Z_DATA_ERROR() =>
        return "Data error (corrupted or incomplete)"
    if code == Z_MEM_ERROR() =>
        return "Memory error"
    if code == Z_BUF_ERROR() =>
        return "Buffer error (output too small)"
    if code == Z_VERSION_ERROR() =>
        return "Version error"
    return "Unknown error"

# ==============================================================================
# High-Level Compression API
# ==============================================================================

# compress_to - Compress data into provided buffer
# Returns number of bytes written, or -1 on error
native fn compress_to(source: byte[], dest: byte[]): int =>
    var destLen: uint = dest.length
    var result: int = compress(dest as ref, destLen, source as ref, source.length)
    if result != 0 =>
        return -1
    var written: int = destLen
    return written

# compress_to_level - Compress with specific level into provided buffer
# Returns number of bytes written, or -1 on error
native fn compress_to_level(source: byte[], dest: byte[], level: int): int =>
    var destLen: uint = dest.length
    var result: int = compress2(dest as ref, destLen, source as ref, source.length, level)
    if result != 0 =>
        return -1
    var written: int = destLen
    return written

# decompress_to - Decompress data into provided buffer
# Returns number of bytes written, or -1 on error
native fn decompress_to(source: byte[], dest: byte[]): int =>
    var destLen: uint = dest.length
    var result: int = uncompress(dest as ref, destLen, source as ref, source.length)
    if result != 0 =>
        return -1
    var written: int = destLen
    return written

# max_compressed_size - Calculate maximum possible compressed size
fn max_compressed_size(source_len: int): int =>
    var ulen: uint = source_len
    var bound: uint = compressBound(ulen)
    var result: int = bound
    return result

# ==============================================================================
# Convenience Wrappers (allocate output buffer automatically)
# ==============================================================================

# compress_data - Compress data with default compression level
# Returns compressed data, or empty array on error
native fn compress_data(source: byte[]): byte[] =>
    if source.length == 0 =>
        return source

    var bound: int = max_compressed_size(source.length)
    var dest: byte[bound]
    var destLen: uint = bound

    var result: int = compress(dest as ref, destLen, source as ref, source.length)
    if result != 0 =>
        var empty: byte[0]
        return empty

    var written: int = destLen
    return dest[0..written] as val

# compress_data_level - Compress data with specified level
# Returns compressed data, or empty array on error
native fn compress_data_level(source: byte[], level: int): byte[] =>
    if source.length == 0 =>
        return source

    var bound: int = max_compressed_size(source.length)
    var dest: byte[bound]
    var destLen: uint = bound

    var result: int = compress2(dest as ref, destLen, source as ref, source.length, level)
    if result != 0 =>
        var empty: byte[0]
        return empty

    var written: int = destLen
    return dest[0..written] as val

# decompress_data - Decompress data
# expected_size: the size of the original uncompressed data
# Returns decompressed data, or empty array on error
native fn decompress_data(source: byte[], expected_size: int): byte[] =>
    if source.length == 0 =>
        return source

    var dest: byte[expected_size]
    var destLen: uint = expected_size

    var result: int = uncompress(dest as ref, destLen, source as ref, source.length)
    if result != 0 =>
        var empty: byte[0]
        return empty

    var written: int = destLen
    return dest[0..written] as val

# ==============================================================================
# Utility Functions
# ==============================================================================

# is_compressed - Simple heuristic to check if data might be zlib-compressed
fn is_compressed(data: byte[]): bool =>
    if data.length < 2 =>
        return false

    # zlib header: first byte is CMF (usually 0x78 for deflate)
    var cmf: int = data[0]
    var flg: int = data[1]

    # Common zlib headers: 78 01, 78 5E, 78 9C, 78 DA
    if cmf != 120 =>
        return false

    var check: int = cmf * 256 + flg
    return check % 31 == 0

# compression_ratio - Calculate compression ratio
# Returns ratio as percentage (e.g., 75.5 means compressed to 75.5% of original)
fn compression_ratio(original_size: int, compressed_size: int): double =>
    if original_size == 0 =>
        return 0.0
    return (compressed_size * 100.0) / original_size

# space_saved - Calculate space saved by compression
# Returns percentage saved (e.g., 24.5 means saved 24.5% of original size)
fn space_saved(original_size: int, compressed_size: int): double =>
    return 100.0 - compression_ratio(original_size, compressed_size)
